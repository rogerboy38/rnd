{
 "creation": "2025-08-26 19:00:12.615473",
 "docstatus": 0,
 "doctype": "Client Script",
 "dt": "Batch AMB",
 "enabled": 0,
 "idx": 0,
 "modified": "2025-08-26 19:00:12.615473",
 "modified_by": "Administrator",
 "module": "RND",
 "name": "batch_amb_old",
 "owner": "Administrator",
 "script": "// Batch AMB Client Script - Proper Nested Set Implementation\r\n// This version prevents self-referencing and handles level changes correctly\r\n\r\nfrappe.ui.form.on('Batch AMB', {\r\n    onload: function(frm) {\r\n        console.log('Batch AMB form loaded');\r\n        \r\n        // Set default values when creating new document\r\n        if (frm.is_new()) {\r\n            frm.set_value('custom_batch_level', '1');\r\n            frm.set_value('is_group', 1);\r\n        }\r\n    },\r\n    \r\n    refresh: function(frm) {\r\n        // Auto-generate batch code when all required fields are filled\r\n        if (should_auto_generate(frm)) {\r\n            generate_batch_code(frm);\r\n        }\r\n        \r\n        // Add custom buttons for creating sublots\r\n        if (!frm.is_new() && frm.doc.custom_batch_level == '1') {\r\n            frm.add_custom_button(__('Create Sublot'), function() {\r\n                create_sublot_batch(frm);\r\n            });\r\n        }\r\n    },\r\n    \r\n    work_order_ref: function(frm) {\r\n        if (frm.doc.work_order_ref) {\r\n            fetch_work_order_data(frm);\r\n        }\r\n    },\r\n    \r\n    custom_batch_level: function(frm) {\r\n        console.log('Batch Level changed to:', frm.doc.custom_batch_level);\r\n        \r\n        // Prevent changing level of existing documents\r\n        if (!frm.is_new()) {\r\n            frappe.msgprint('Cannot change batch level of existing documents. Create a new document for different levels.');\r\n            frm.set_value('custom_batch_level', frm.doc.__original_level || '1');\r\n            return;\r\n        }\r\n        \r\n        // Clear parent when changing to level 1\r\n        if (frm.doc.custom_batch_level == '1') {\r\n            frm.set_value('parent_batch_amb', '');\r\n            frm.set_value('is_group', 1);\r\n        } else {\r\n            frm.set_value('is_group', 0);\r\n        }\r\n        \r\n        // Auto-generate batch code when level changes\r\n        if (should_auto_generate(frm)) {\r\n            generate_batch_code(frm);\r\n        }\r\n    },\r\n    \r\n    parent_batch_amb: function(frm) {\r\n        console.log('Parent Batch selected:', frm.doc.parent_batch_amb);\r\n        \r\n        // Prevent self-referencing\r\n        if (frm.doc.parent_batch_amb === frm.doc.name) {\r\n            frappe.msgprint('A batch cannot be its own parent');\r\n            frm.set_value('parent_batch_amb', '');\r\n            return;\r\n        }\r\n        \r\n        // Auto-generate batch code when parent is selected\r\n        if (frm.doc.parent_batch_amb && should_auto_generate(frm)) {\r\n            generate_batch_code(frm);\r\n        }\r\n    },\r\n    \r\n    before_save: function(frm) {\r\n        console.log('Before save validation');\r\n        \r\n        // Prevent self-referencing\r\n        if (frm.doc.parent_batch_amb === frm.doc.name) {\r\n            frappe.throw('A batch cannot be its own parent');\r\n            return false;\r\n        }\r\n        \r\n        // Validate batch level and parent relationship\r\n        if (frm.doc.custom_batch_level > '1' && !frm.doc.parent_batch_amb) {\r\n            frappe.throw('Parent Batch AMB is required for level ' + frm.doc.custom_batch_level);\r\n            return false;\r\n        }\r\n        \r\n        // Store original level for preventing changes\r\n        if (!frm.doc.__original_level) {\r\n            frm.doc.__original_level = frm.doc.custom_batch_level;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n});\r\n\r\nfunction create_sublot_batch(parent_frm) {\r\n    // Create a new Batch AMB document for sublot\r\n    frappe.new_doc('Batch AMB', {\r\n        'custom_batch_level': '2',\r\n        'parent_batch_amb': parent_frm.doc.name,\r\n        'work_order_ref': parent_frm.doc.work_order_ref,\r\n        'sales_order_related': parent_frm.doc.sales_order_related,\r\n        'production_plant_name': parent_frm.doc.production_plant_name,\r\n        'custom_batch_year': parent_frm.doc.custom_batch_year,\r\n        'custom_plant_code': parent_frm.doc.custom_plant_code,\r\n        'tds_link': parent_frm.doc.tds_link,\r\n        'wo_item_name': parent_frm.doc.wo_item_name,\r\n        'item_to_manufacture': parent_frm.doc.item_to_manufacture,\r\n        'tds_item_name': parent_frm.doc.tds_item_name,\r\n        'is_group': 0\r\n    });\r\n}\r\n\r\nfunction fetch_work_order_data(frm) {\r\n    frappe.call({\r\n        method: 'frappe.client.get',\r\n        args: {\r\n            doctype: 'Work Order',\r\n            name: frm.doc.work_order_ref\r\n        },\r\n        callback: function(r) {\r\n            if (r.message) {\r\n                const wo = r.message;\r\n                \r\n                // Set related fields\r\n                frm.set_value('sales_order_related', wo.sales_order);\r\n                frm.set_value('wo_item_name', wo.item_name);\r\n                frm.set_value('item_to_manufacture', wo.production_item);\r\n                \r\n                // Fetch additional data\r\n                fetch_sales_order_data(frm, wo.sales_order);\r\n                fetch_item_data(frm, wo.production_item);\r\n                \r\n                // Auto-generate batch code after setting work order data\r\n                if (should_auto_generate(frm)) {\r\n                    setTimeout(function() {\r\n                        generate_batch_code(frm);\r\n                    }, 500);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction fetch_sales_order_data(frm, sales_order) {\r\n    if (!sales_order) return;\r\n    \r\n    frappe.call({\r\n        method: 'frappe.client.get',\r\n        args: {\r\n            doctype: 'Sales Order',\r\n            name: sales_order\r\n        },\r\n        callback: function(r) {\r\n            if (r.message) {\r\n                // You can set additional fields from sales order if needed\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction fetch_item_data(frm, item_code) {\r\n    if (!item_code) return;\r\n    \r\n    frappe.call({\r\n        method: 'frappe.client.get',\r\n        args: {\r\n            doctype: 'Item',\r\n            name: item_code\r\n        },\r\n        callback: function(r) {\r\n            if (r.message) {\r\n                const item = r.message;\r\n                \r\n                // Set TDS related fields\r\n                //frm.set_value('tds_link', item.item_custom_product_key_tds);\r\n                //frm.set_value('tds_item_name', item.item_name);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction should_auto_generate(frm) {\r\n    // Check if all required fields are filled for auto-generation\r\n    const required_fields = [\r\n        'work_order_ref',\r\n        'production_plant_name',\r\n        'custom_batch_level'\r\n    ];\r\n    \r\n    for (let field of required_fields) {\r\n        if (!frm.doc[field]) {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    console.log('All required fields filled, auto-generating batch code');\r\n    return true;\r\n}\r\n\r\nfunction generate_batch_code(frm) {\r\n    const level = parseInt(frm.doc.custom_batch_level) || 1;\r\n    console.log('Generating batch code for level:', level);\r\n    \r\n    if (level === 1) {\r\n        // Generate base batch code for Level 1\r\n        generate_level_1_batch_code(frm);\r\n    } else {\r\n        // Generate hierarchical batch code for Level 2+\r\n        generate_sublot_batch_code(frm, level);\r\n    }\r\n}\r\n\r\nfunction generate_level_1_batch_code(frm) {\r\n    // Get base components from work order and form data\r\n    get_base_components(frm, function(components) {\r\n        console.log('Base components:', components);\r\n        \r\n        const product_code = components.product_code;\r\n        const consecutive = components.consecutive.toString().padStart(5, '0');\r\n        const plant_code = components.plant_code;\r\n        \r\n        // Generate final batch code: PRODUCTCODE + CONSECUTIVE + PLANTCODE\r\n        const final_batch_code = `${product_code}${consecutive}${plant_code}`;\r\n        \r\n        console.log('Final batch code generated:', final_batch_code);\r\n        \r\n        // Set the generated batch code\r\n        frm.set_value('title', final_batch_code);\r\n        frm.set_value('custom_generated_batch_name', final_batch_code);\r\n        \r\n        // Store business data in custom fields\r\n        frm.set_value('custom_consecutive_number', consecutive);\r\n        frm.set_value('custom_plant_code', plant_code);\r\n        \r\n        frm.refresh_field('title');\r\n        frm.refresh_field('custom_generated_batch_name');\r\n    });\r\n}\r\n\r\nfunction generate_sublot_batch_code(frm, level) {\r\n    if (!frm.doc.parent_batch_amb) {\r\n        console.log('No parent selected for level', level);\r\n        return;\r\n    }\r\n    \r\n    // Prevent self-referencing\r\n    if (frm.doc.parent_batch_amb === frm.doc.name) {\r\n        frappe.msgprint('A batch cannot be its own parent');\r\n        frm.set_value('parent_batch_amb', '');\r\n        return;\r\n    }\r\n    \r\n    // For Level 2+, get the parent's batch name and append sublot number\r\n    frappe.call({\r\n        method: 'frappe.client.get',\r\n        args: {\r\n            doctype: 'Batch AMB',\r\n            name: frm.doc.parent_batch_amb\r\n        },\r\n        callback: function(r) {\r\n            if (r.message) {\r\n                const parent_batch = r.message;\r\n                const parent_batch_code = parent_batch.title || parent_batch.custom_generated_batch_name;\r\n                \r\n                if (!parent_batch_code) {\r\n                    frappe.msgprint('Parent batch does not have a valid batch code');\r\n                    return;\r\n                }\r\n                \r\n                console.log('Parent batch code:', parent_batch_code);\r\n                \r\n                // Get next consecutive number for this sublot\r\n                get_next_sublot_consecutive(frm, parent_batch_code, function(next_consecutive) {\r\n                    console.log('Next consecutive for level', level, ':', next_consecutive);\r\n                    \r\n                    // Generate sublot code: PARENT_CODE-CONSECUTIVE\r\n                    const final_batch_code = `${parent_batch_code}-${next_consecutive}`;\r\n                    \r\n                    console.log('Final batch code generated:', final_batch_code);\r\n                    \r\n                    // Set the generated batch code\r\n                    frm.set_value('title', final_batch_code);\r\n                    frm.set_value('custom_generated_batch_name', final_batch_code);\r\n                    \r\n                    // Store sublot consecutive number in custom field\r\n                    frm.set_value('custom_sublot_consecutive', next_consecutive);\r\n                    \r\n                    frm.refresh_field('title');\r\n                    frm.refresh_field('custom_generated_batch_name');\r\n                });\r\n            } else {\r\n                frappe.msgprint('Could not fetch parent batch information');\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction get_base_components(frm, callback) {\r\n    // Extract product code from work order or item\r\n    frappe.call({\r\n        method: 'frappe.client.get',\r\n        args: {\r\n            doctype: 'Work Order',\r\n            name: frm.doc.work_order_ref\r\n        },\r\n        callback: function(r) {\r\n            if (r.message) {\r\n                const wo = r.message;\r\n                \r\n                // Extract product code (first 4 digits from item code or name)\r\n                let product_code = '';\r\n                if (wo.production_item) {\r\n                    const match = wo.production_item.match(/^(\\d{4})/);\r\n                    product_code = match ? match[1] : '0000';\r\n                } else {\r\n                    product_code = '0000';\r\n                }\r\n                \r\n                // Get consecutive number from work order name\r\n                let consecutive = 1;\r\n                const wo_match = wo.name.match(/(\\d+)$/);\r\n                if (wo_match) {\r\n                    consecutive = parseInt(wo_match[1]);\r\n                }\r\n                \r\n                // Get year and plant code from form\r\n                const year = frm.doc.custom_batch_year || '25';\r\n                const plant_code = frm.doc.custom_plant_code || '1';\r\n                \r\n                callback({\r\n                    product_code: product_code,\r\n                    consecutive: consecutive,\r\n                    year: year,\r\n                    plant_code: plant_code,\r\n                    source: 'work_order'\r\n                });\r\n            } else {\r\n                // Fallback values\r\n                callback({\r\n                    product_code: '0000',\r\n                    consecutive: 1,\r\n                    year: '25',\r\n                    plant_code: '1',\r\n                    source: 'fallback'\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction get_next_sublot_consecutive(frm, parent_batch_code, callback) {\r\n    // Find existing sublots for this parent\r\n    frappe.call({\r\n        method: 'frappe.client.get_list',\r\n        args: {\r\n            doctype: 'Batch AMB',\r\n            filters: {\r\n                'parent_batch_amb': frm.doc.parent_batch_amb,\r\n                'name': ['!=', frm.doc.name || '']  // Exclude current document if editing\r\n            },\r\n            fields: ['name', 'title', 'custom_generated_batch_name'],\r\n            limit_page_length: 100\r\n        },\r\n        callback: function(r) {\r\n            let next_consecutive = 1;\r\n            \r\n            if (r.message && r.message.length > 0) {\r\n                // Extract consecutive numbers from existing sublots\r\n                const existing_consecutives = [];\r\n                \r\n                r.message.forEach(function(batch) {\r\n                    const batch_name = batch.title || batch.custom_generated_batch_name || '';\r\n                    \r\n                    // Look for pattern: PARENT_CODE-NUMBER\r\n                    const pattern = new RegExp(`^${parent_batch_code.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}-(\\\\d+)$`);\r\n                    const match = batch_name.match(pattern);\r\n                    \r\n                    if (match) {\r\n                        existing_consecutives.push(parseInt(match[1]));\r\n                    }\r\n                });\r\n                \r\n                // Find the next available consecutive number\r\n                if (existing_consecutives.length > 0) {\r\n                    next_consecutive = Math.max(...existing_consecutives) + 1;\r\n                }\r\n            }\r\n            \r\n            callback(next_consecutive);\r\n        }\r\n    });\r\n}\r\n\r\nconsole.log('Batch AMB client script loaded successfully');\r\n",
 "view": "Form"
}
